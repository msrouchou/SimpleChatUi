@page "/"
@using Markdig
@using Markdown.ColorCode
@using SimpleChatUi.Hubs
@using System.Text.RegularExpressions
@using static SimpleChatUi.Hubs.ChatHubService

@inject IJSRuntime JSRuntime

<div class="chat-container">
    @if (_chatHistory.Count > 0)
    {
        @foreach (var entry in BuildChatSequence())
        {
                    // User Prompt
            <div class="chat-message-container">
                <div class="chat-message-header">
                    <span class="bi bi-person" aria-hidden="true" />
                    <label>You</label>
                </div>
                <div class="chat-message user-prompt">@entry.UserMessage</div>
            </div>

            // AI Answer
            <div class="chat-message-container">
                <div class="chat-message-header">
                    <span class="bi bi-robot" aria-hidden="true" />
                    <label>Assistant</label>
                </div>
                <div class="chat-message bot-answer">@entry.BotMessage</div>
            </div>
        }
    }

    <div id="input-container" class="input-container input-group mb-3">
        <input type="text"
               class="form-control hide-border"
               placeholder="Message AI Assistant"
               aria-label="Message AI Assistant"
               aria-describedby="basic-addon2"
               @bind="_userMessage"
               @onkeyup="HandleKeyPress" />
        <div class="input-group-append" m8>
            <span class="bi bi-send" type="button" @onclick="SendMessage"></span>
        </div>
    </div>

</div>

@code {

    [Inject]
    public required ChatHubService ChatHubService { get; set; }

    [Inject]
    public required ILogger<Chat> Logger { get; set; }

    private string _user = $"{Environment.UserName}-{DateTimeOffset.UtcNow.ToString().Replace(' ', '_')}";

    private enum Sender
    {
        User,
        Bot,
    }

    private Dictionary<Sender, List<MarkupString>> _chatHistory = new();
    private string _userMessage = "";
    private MarkdownPipeline? _pipeline;

    protected override void OnInitialized()
    {
        ChatHubService.BotMessageReceived += OnBotMessageReceived;
        _pipeline = new MarkdownPipelineBuilder()
        .UseAdvancedExtensions()
        .UseColorCode()
        .Build();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await ScrollToElementAsync("input-container");
    }

    private async Task SendMessage()
    {
        if (string.IsNullOrWhiteSpace(_userMessage))
            return;

        await DisplayUserPrompt();

        // Call the SignalR method to send the message
        await ChatHubService.SendMessageToBotAsync(_user, _userMessage);

        _userMessage = "";

        await DisplayBotAnswer(isEchoBot: false);
    }

    private async Task HandleKeyPress(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            await SendMessage();
        }
    }

    private async Task DisplayUserPrompt() => await AddMessageToHistory(Sender.User, _userMessage);

    private Random rnd = new Random();

    private async Task DisplayBotAnswer(bool isEchoBot)
    {
        if (isEchoBot)
        {
            var chunks = EchoBot.GetAnswer(_userMessage, 10);

            // clear UI input
            _userMessage = "";

            for (int i = 0; i < chunks.Count; i++)
            {
                var chunk = chunks[i];
                if (i == 0)
                {
                    await AddMessageToHistory(Sender.Bot, chunk);
                }
                else
                {
                    // keep updating the last answer while streaming chunks
                    var currentAnswer = _chatHistory[Sender.Bot].Last().Value;
                    currentAnswer += chunk;
                    _chatHistory[Sender.Bot][_chatHistory[Sender.Bot].Count - 1] = new MarkupString(currentAnswer);
                }

                StateHasChanged();
                await Task.Delay(rnd.Next(0, 1000));

                return;
            }
        }

        await ScrollToElementAsync("input-container");
    }

    int chunkIndex;
    private async void OnBotMessageReceived(object? sender, BotAnswerReceivedEventArgs e)
    {
        if (!e.User.Equals(_user))
        {
            Logger.LogWarning("Received irrelevant answer for {IrrelevantUser} while current chat is for {User}", e.User, _user);
            return;
        }

        chunkIndex++;
        if (chunkIndex == 1) // first chunk
        {
            await AddMessageToHistory(Sender.Bot, e.Answer);
            return;
        }

        var lastIndex = _chatHistory[Sender.Bot].Count - 1;

        if (e.Answer.Equals("%%%DONE%%"))
        {
            Logger.LogInformation("Rendering final response for user {User}...", e.User);
            var fullAnswer = Markdown.ToHtml(_chatHistory[Sender.Bot][lastIndex].Value, _pipeline);
            _chatHistory[Sender.Bot][lastIndex] = new(fullAnswer);
            await UpdateStateAsync();

            chunkIndex = 0;
            return;
        }

        //var chunk = e.Answer.EndsWith(".") ? $"{e.Answer}" : e.Answer;
        var chunk = e.Answer;

        _chatHistory[Sender.Bot][lastIndex] = new(_chatHistory[Sender.Bot][lastIndex] + chunk);
        // var currentAnswer = _chatHistory[Sender.Bot].Last();
        // currentAnswer += e.Answer;//append?
        // _chatHistory[Sender.Bot][_chatHistory[Sender.Bot].Count - 1] = currentAnswer;

        // if (Regex.Match(chunk, pattern).Success)
        // {
        //     var completion = Markdown.ToHtml(_chatHistory[Sender.Bot][lastIndex].Value, _pipeline);

        //     _chatHistory[Sender.Bot][lastIndex] = new(completion);
        // }

        await UpdateStateAsync();
    }

    //private async Task AddMessageToHistory(Sender sender, BotAnswerReceivedEventArgs e)
    private async Task AddMessageToHistory(Sender sender, string answer)
    {
        if (_chatHistory.TryGetValue(sender, out var messages))
        {
            _chatHistory[sender].Add(new(answer));
        }
        else
        {
            _chatHistory.Add(sender, [new(answer)]);
        }

        await UpdateStateAsync();
    }

    private async Task UpdateStateAsync()
    {
        await InvokeAsync(() =>
        {
            StateHasChanged();
        });
    }

    private IEnumerable<dynamic> BuildChatSequence()
    {
        var userMessages = _chatHistory.ContainsKey(Sender.User) ? _chatHistory[Sender.User] : new List<MarkupString>();
        var botMessages = _chatHistory.ContainsKey(Sender.Bot) ? _chatHistory[Sender.Bot] : new List<MarkupString>();

        var chatSequence = userMessages.Zip(botMessages.DefaultIfEmpty(), (user, bot) => new { UserMessage = user, BotMessage = bot });
        return chatSequence;
    }

    private async Task ScrollToElementAsync(string elementId) =>
        await JSRuntime.InvokeVoidAsync("scrollToElement", elementId);
}
